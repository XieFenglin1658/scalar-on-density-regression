---
title: "scalar-on-density-regression"
author: "Fenglin Xie"
date: "2025-11-18"
output: github_document
---
```{r}
# 密度函数估计质量对权重系数估计影响的模拟研究
# 框架：测量误差模型 - 样本量增加 -> 密度估计改善 -> 权重估计改善

library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
library(splines)
library(matrixStats)

# ==================== 参数设置 ====================

# 总体参数：所有个体的真实密度都围绕这个中心
alpha0 = 2    # Beta分布的中心alpha参数
beta0 = 5     # Beta分布的中心beta参数
sigma_alpha = 0.2  # 个体间alpha参数的变异（小变异，确保"大差不差"）
sigma_beta = 0.5   # 个体间beta参数的变异

# 真实的权重函数
true_beta_func = function(t) {
  # 设定一个真实的权重函数，例如在中间区域权重较高
  0.5 + 2 * (t - 0.5)^2
}

# 样本量序列（从很小到很大）
sample_sizes = c(10, 20, 50, 100, 200, 500, 1000)

# 模拟重复次数
n_replicates = 200

# 个体数量
n_individuals = 100

# 误差项标准差
sigma_error = 0.1

# 基函数数量（用于估计权重函数）
n_basis = 5

# ==================== 辅助函数 ====================

#' 生成真实的个体密度函数参数
generate_true_parameters = function(n) {
  data.frame(
    individual_id = 1:n,
    alpha_true = pmax(0.1, rnorm(n, alpha0, sigma_alpha)),
    beta_true = pmax(0.1, rnorm(n, beta0, sigma_beta))
  )
}

#' 从Beta分布生成观测数据
generate_observations = function(alpha, beta, sample_size) {
  rbeta(sample_size, alpha, beta)
}

#' 使用矩估计法估计Beta分布参数
estimate_beta_params <- function(observations) {
  if (length(observations) < 2) {
    return(list(alpha_hat = alpha0, beta_hat = beta0))
  }
  
  m1 <- mean(observations)
  m2 <- mean(observations^2)
  
  if (m2 <= m1^2 || m1 <= 0 || m1 >= 1) {
    return(list(alpha_hat = alpha0, beta_hat = beta0))
  }
  
  variance <- m2 - m1^2
  alpha_hat <- m1 * (m1 * (1 - m1) / variance - 1)
  beta_hat <- (1 - m1) * (m1 * (1 - m1) / variance - 1)
  
  # 确保参数为正
  list(
    alpha_hat = max(0.1, alpha_hat),
    beta_hat = max(0.1, beta_hat)
  )
}

#' 计算Beta分布的均值（用于生成响应变量）
beta_mean <- function(alpha, beta) {
  alpha / (alpha + beta)
}

#' 计算权重函数的积分项
compute_integral <- function(alpha, beta, weight_func) {
  # 数值积分：计算 ∫ weight_func(t) * Beta(t; alpha, beta) dt
  t_grid <- seq(0.001, 0.999, length.out = 1000)
  integrand <- weight_func(t_grid) * dbeta(t_grid, alpha, beta)
  sum(integrand) * (t_grid[2] - t_grid[1])
}

#' 使用基函数展开法估计权重函数
estimate_weight_function <- function(estimated_densities, Y, n_basis) {
  # 创建B样条基函数
  t_grid <- seq(0, 1, length.out = 100)
  basis <- bs(t_grid, df = n_basis, degree = 3, intercept = TRUE)
  
  # 计算设计矩阵 X
  X_matrix <- matrix(0, nrow = length(Y), ncol = n_basis)
  
  for (i in 1:length(Y)) {
    alpha_hat <- estimated_densities$alpha_hat[i]
    beta_hat <- estimated_densities$beta_hat[i]
    
    for (j in 1:n_basis) {
      # 计算 ∫ B_j(t) * f_i_hat(t) dt
      integrand <- basis[, j] * dbeta(t_grid, alpha_hat, beta_hat)
      X_matrix[i, j] <- sum(integrand) * (t_grid[2] - t_grid[1])
    }
  }
  
  # 拟合线性模型（带截距）
  X_design <- cbind(1, X_matrix)  # 添加截距项
  coefficients <- solve(t(X_design) %*% X_design, t(X_design) %*% Y)
  
  # 重构权重函数估计
  beta_hat_func <- function(t) {
    basis_t <- predict(basis, t)
    coefficients[1] + as.numeric(basis_t %*% coefficients[-1])
  }
  
  return(beta_hat_func)
}

#' 计算函数之间的L2距离
compute_l2_distance <- function(func1, func2, grid_points = 100) {
  t_vals <- seq(0, 1, length.out = grid_points)
  differences <- func1(t_vals) - func2(t_vals)
  sqrt(mean(differences^2))
}

# ==================== 主模拟函数 ====================

run_simulation <- function(sample_size, n_replicates) {
  cat("正在处理样本量:", sample_size, "\n")
  
  results <- list()
  
  for (rep in 1:n_replicates) {
    # 1. 生成真实的个体参数
    true_params <- generate_true_parameters(n_individuals)
    
    # 2. 生成响应变量（基于真实密度）
    true_params <- true_params %>%
      mutate(
        integral_term = map2_dbl(alpha_true, beta_true, ~ compute_integral(.x, .y, true_beta_func)),
        Y = integral_term + rnorm(n(), 0, sigma_error)
      )
    
    # 3. 生成观测数据并估计密度函数
    estimated_densities <- true_params %>%
      mutate(
        observations = map2(alpha_true, beta_true, ~ generate_observations(.x, .y, sample_size)),
        param_estimates = map(observations, estimate_beta_params),
        alpha_hat = map_dbl(param_estimates, "alpha_hat"),
        beta_hat = map_dbl(param_estimates, "beta_hat")
      )
    
    # 4. 估计权重函数
    beta_hat_func <- estimate_weight_function(estimated_densities, estimated_densities$Y, n_basis)
    
    # 5. 计算估计误差
    density_estimation_error <- with(estimated_densities, {
      mean(sqrt((alpha_hat - alpha_true)^2 + (beta_hat - beta_true)^2))
    })
    
    weight_estimation_error <- compute_l2_distance(beta_hat_func, true_beta_func)
    
    # 存储结果
    results[[rep]] <- list(
      sample_size = sample_size,
      replicate = rep,
      beta_hat_func = beta_hat_func,
      density_error = density_estimation_error,
      weight_error = weight_estimation_error
    )
  }
  
  return(results)
}

# ==================== 运行模拟 ====================

cat("开始模拟...\n")
simulation_results <- list()

for (sample_size in sample_sizes) {
  results <- run_simulation(sample_size, n_replicates)
  simulation_results <- c(simulation_results, results)
}

# ==================== 结果整理 ====================

# 提取误差数据
error_data <- map_df(simulation_results, ~ {
  data.frame(
    sample_size = .x$sample_size,
    density_error = .x$density_error,
    weight_error = .x$weight_error
  )
})

# 计算权重函数在网格点上的估计
t_grid <- seq(0, 1, length.out = 50)
weight_estimates <- map_df(simulation_results, ~ {
  estimates <- .x$beta_hat_func(t_grid)
  data.frame(
    sample_size = .x$sample_size,
    replicate = .x$replicate,
    t = t_grid,
    beta_hat = estimates
  )
})

# ==================== 可视化 ====================

# 1. 密度估计误差随样本量的变化
p1 <- ggplot(error_data, aes(x = factor(sample_size), y = density_error)) +
  geom_boxplot(aes(fill = factor(sample_size)), alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3, color = "red") +
  labs(
    title = "密度函数估计误差随样本量的变化",
    subtitle = "样本量增加 → 密度估计更准确",
    x = "样本量",
    y = "密度参数估计误差"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

# 2. 权重函数估计误差随样本量的变化
p2 <- ggplot(error_data, aes(x = factor(sample_size), y = weight_error)) +
  geom_boxplot(aes(fill = factor(sample_size)), alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3, color = "red") +
  labs(
    title = "权重函数估计误差随样本量的变化",
    subtitle = "密度估计改善 → 权重估计改善",
    x = "样本量",
    y = "权重函数L2误差"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

# 3. 两种误差的关系
p3 <- ggplot(error_data, aes(x = density_error, y = weight_error)) +
  geom_point(alpha = 0.5, aes(color = factor(sample_size))) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  labs(
    title = "密度估计误差与权重估计误差的关系",
    x = "密度参数估计误差",
    y = "权重函数估计误差",
    color = "样本量"
  ) +
  theme_minimal()

# 4. 权重函数估计的演变
# 计算每个样本量下的平均估计
weight_summary <- weight_estimates %>%
  group_by(sample_size, t) %>%
  summarise(
    beta_hat_mean = mean(beta_hat),
    beta_hat_sd = sd(beta_hat),
    .groups = 'drop'
  ) %>%
  mutate(
    beta_true = true_beta_func(t)
  )

p4 <- ggplot(weight_summary, aes(x = t)) +
  geom_ribbon(aes(ymin = beta_hat_mean - beta_hat_sd, 
                  ymax = beta_hat_mean + beta_hat_sd, 
                  fill = factor(sample_size)), 
              alpha = 0.2) +
  geom_line(aes(y = beta_hat_mean, color = factor(sample_size)), size = 1) +
  geom_line(aes(y = beta_true), color = "black", linetype = "dashed", size = 1.5) +
  labs(
    title = "权重函数估计随样本量的演变",
    subtitle = "实线: 估计均值, 阴影: ±1标准差, 虚线: 真实函数",
    x = "t",
    y = "β(t)",
    color = "样本量",
    fill = "样本量"
  ) +
  theme_minimal()

# 5. 收敛速率分析
convergence_data <- error_data %>%
  group_by(sample_size) %>%
  summarise(
    mean_density_error = mean(density_error),
    mean_weight_error = mean(weight_error),
    .groups = 'drop'
  )

p5 <- ggplot(convergence_data, aes(x = sample_size)) +
  geom_point(aes(y = mean_density_error, color = "密度估计误差"), size = 3) +
  geom_point(aes(y = mean_weight_error, color = "权重估计误差"), size = 3) +
  geom_line(aes(y = mean_density_error, color = "密度估计误差"), size = 1) +
  geom_line(aes(y = mean_weight_error, color = "权重估计误差"), size = 1) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "误差收敛速率（对数尺度）",
    x = "样本量（对数）",
    y = "平均误差（对数）",
    color = "误差类型"
  ) +
  theme_minimal()

# ==================== 显示结果 ====================

cat("模拟完成！显示结果...\n")

print(p1)
print(p2)
print(p3)
print(p4)
print(p5)

# ==================== 统计摘要 ====================

cat("\n=== 统计摘要 ===\n")
summary_stats <- error_data %>%
  group_by(sample_size) %>%
  summarise(
    density_error_mean = mean(density_error),
    density_error_sd = sd(density_error),
    weight_error_mean = mean(weight_error),
    weight_error_sd = sd(weight_error),
    .groups = 'drop'
  )

print(summary_stats)

# 拟合收敛速率模型
convergence_model_density <- lm(log(mean_density_error) ~ log(sample_size), 
                               data = convergence_data)
convergence_model_weight <- lm(log(mean_weight_error) ~ log(sample_size), 
                              data = convergence_data)

cat("\n=== 收敛速率分析 ===\n")
cat(sprintf("密度估计误差收敛速率: %.3f (理论期望: -0.5)\n", 
            -coef(convergence_model_density)[2]))
cat(sprintf("权重估计误差收敛速率: %.3f (理论期望: -0.5)\n", 
            -coef(convergence_model_weight)[2]))

# ==================== 保存结果 ====================

# 保存主要结果
write.csv(error_data, "simulation_errors.csv", row.names = FALSE)
write.csv(weight_summary, "weight_function_estimates.csv", row.names = FALSE)

cat("\n结果已保存到文件:\n")
cat("- simulation_errors.csv: 误差数据\n")
cat("- weight_function_estimates.csv: 权重函数估计\n")

cat("\n=== 主要发现 ===\n")
cat("1. 样本量增加显著改善密度函数估计准确性\n")
cat("2. 密度估计改善直接导致权重函数估计改善\n")
cat("3. 误差收敛速率接近理论预期(1/√n)\n")
cat("4. 小样本时估计方差大，大样本时估计稳定\n")
```

