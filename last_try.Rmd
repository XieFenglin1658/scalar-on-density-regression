---
title: "last_try!!!"
author: "Fenglin Xie"
date: "2025-12-16"
output: github_document
---

# 第一步：加载必要的包和设置参数
```{r}
# 1. 加载必要的包
library(tidyverse)    # 数据处理和绘图
library(fda)          # 函数型数据分析
library(patchwork)    # 组合多个图表

# 设置随机种子，确保结果可重复
set.seed(123)

# 2. 定义基本参数
n <- 100               # 个体数量
sigma <- 0.2          # 误差项的标准差
m_values <- c(50, 100, 500, 1000, 5000, 10000)  # 不同样本量
```

# 第二步：定义真实的系数函数 β(q)
```{r}
# 3. 定义真实的系数函数 β(q)
# 我们设计一个简单但非平凡的系数函数
true_beta <- function(q) {
  # 使用两个高斯峰的叠加
  1.5 * exp(-20 * (q - 0.3)^2) + 2.0 * exp(-15 * (q - 0.7)^2)
}

# 可视化真实的β函数
q_grid <- seq(0, 1, length.out = 100)
beta_values <- sapply(q_grid, true_beta)

plot_beta_true <- ggplot(data.frame(q = q_grid, beta = beta_values), 
                         aes(x = q, y = beta)) +
  geom_line(color = "darkblue", size = 1.5) +
  labs(title = "True Coefficient Function β(q)",
       x = "Quantile q", y = "β(q)") +
  theme_minimal()

print(plot_beta_true)
```

# 第三步：生成真实的个体密度函数 f_i(t)
```{r}
# 4. 生成n个真实的密度函数 f_i(t)
# 所有密度函数都来自Beta分布族，但参数略有不同

# 设置Beta分布的中心参数
alpha0 <- 2    # 形状参数1的中心值
beta0 <- 5     # 形状参数2的中心值

# 生成每个个体的参数（围绕中心值有微小波动）
set.seed(456)  # 为参数生成设置单独的随机种子
alphas <- alpha0 + runif(n, -0.3, 0.3)  # 均匀扰动
betas <- beta0 + runif(n, -0.4, 0.4)    # 均匀扰动

# 确保参数为正数
alphas <- pmax(alphas, 2.0)
betas <- pmax(betas, 2.0)

# 创建真实密度函数的列表
true_densities <- list()
true_cdfs <- list()          # 累积分布函数
true_quantiles <- list()     # 分位数函数

for(i in 1:n) {
  # 创建局部变量以避免闭包问题
  alpha_i <- alphas[i]
  beta_i <- betas[i]
  
  # 真实密度函数
  true_densities[[i]] <- function(t) {
    dbeta(t, alpha_i, beta_i)
  }
  
  # 真实累积分布函数
  true_cdfs[[i]] <- function(t) {
    pbeta(t, alpha_i, beta_i)
  }
  
  # 真实分位数函数（逆CDF）
  true_quantiles[[i]] <- function(q) {
    qbeta(q, alpha_i, beta_i)
  }
}

# 可视化几个个体的真实密度函数
t_grid <- seq(0.01, 0.99, length.out = 200)
plot_data <- data.frame()

# 选择5个个体进行可视化
set.seed(789)
selected_individuals <- sample(1:n, 5)

for(i in selected_individuals) {
  density_values <- sapply(t_grid, true_densities[[i]])
  plot_data <- rbind(plot_data,
                     data.frame(t = t_grid,
                                density = density_values,
                                individual = paste("Individual", i)))
}

plot_densities <- ggplot(plot_data, aes(x = t, y = density, color = individual)) +
  geom_line(size = 1) +
  labs(title = "True Density Functions for 5 Randomly Selected Individuals",
       x = "t", y = "f_i(t)") +
  theme_minimal() +
  theme(legend.position = "bottom")

print(plot_densities)
```


# 第四步：定义对数分位数密度变换
```{r}
# 5. 定义对数分位数密度变换函数
# 变换公式：T(f_i) = log(f_i ∘ F_i^{-1})
log_density_quantile_transform <- function(density_func, cdf_func, quantile_func) {
  # 返回一个函数，该函数在分位数q上计算 log(f_i(F_i^{-1}(q)))
  function(q) {
    # q应该在[0,1]范围内
    q <- pmin(pmax(q, 0.01), 0.99)  # 避免边界问题
    # 计算分位数点：t_q = F_i^{-1}(q)
    t_q <- quantile_func(q)
    # 计算在该点的密度值：f_i(t_q)
    f_val <- density_func(t_q)
    # 取对数
    log(max(f_val, 1e-10))  # 避免取log(0)
  }
}

# 测试变换函数
test_q <- seq(0.1, 0.9, by = 0.1)
transformed_values <- sapply(test_q, 
                             log_density_quantile_transform(true_densities[[1]], 
                                                           true_cdfs[[1]], 
                                                           true_quantiles[[1]]))

cat("测试变换函数 - 前几个值:\n")
print(head(transformed_values))
```


# 第五步：生成真实的响应变量 Y
```{r}
# 6. 根据真实模型生成响应变量 Y
# 模型：Y_i = ∫ β(q) * log(f_i(F_i^{-1}(q))) dq + ε_i

# 创建分位数网格用于数值积分
q_grid_integral <- seq(0.05, 0.95, length.out = 100)

# 计算每个个体的变换后密度函数
transformed_densities_true <- list()
for(i in 1:n) {
  transformed_densities_true[[i]] <- 
    log_density_quantile_transform(true_densities[[i]], 
                                   true_cdfs[[i]], 
                                   true_quantiles[[i]])
}

# 数值积分函数（梯形法则，更精确）
inner_product <- function(f, g, grid = q_grid_integral) {
  h <- grid[2] - grid[1]  # 网格间距
  f_vals <- sapply(grid, f)
  g_vals <- sapply(grid, g)
  # 梯形法则
  (h/2) * (f_vals[1]*g_vals[1] + f_vals[length(grid)]*g_vals[length(grid)] + 
           2 * sum(f_vals[-c(1, length(grid))] * g_vals[-c(1, length(grid))]))
}

# 计算每个个体的Y值
set.seed(999)  # 为误差项设置单独的随机种子
Y_true <- numeric(n)
for(i in 1:n) {
  # 计算内积：∫ β(q) * log(f_i(F_i^{-1}(q))) dq
  integral <- inner_product(true_beta, transformed_densities_true[[i]])
  # 添加误差项
  Y_true[i] <- integral + rnorm(1, 0, sigma)
}

# 检查Y的分布
summary_data <- data.frame(Y = Y_true)
plot_Y_dist <- ggplot(summary_data, aes(x = Y)) +
  geom_histogram(bins = 20, fill = "lightblue", color = "black", alpha = 0.7) +
  labs(title = "Distribution of True Response Variable Y",
       x = "Y", y = "Frequency") +
  theme_minimal()

print(plot_Y_dist)
```


# 第六步：从真实密度中抽取观测值并估计密度

```{r}
# 7. 定义核密度估计函数
# 使用density函数进行核密度估计，并进行边界校正

estimate_density_kde <- function(observations, grid_points = 200) {
  # 观测值应该在[0,1]范围内
  observations <- pmin(pmax(observations, 0.001), 0.999)
  
  # 样本量
  n_obs <- length(observations)
  
  # 根据样本量调整带宽
  # 对于小样本，使用较大的带宽以避免过拟合
  # 对于大样本，使用较小的带宽以捕获更多细节
  if(n_obs < 100) {
    bw <- 0.15
  } else if(n_obs < 500) {
    bw <- 0.1
  } else if(n_obs < 1000) {
    bw <- 0.07
  } else if(n_obs < 5000) {
    bw <- 0.05
  } else {
    bw <- 0.03
  }
  
  # 执行核密度估计
  kde_result <- density(observations, bw = bw, from = 0, to = 1, n = grid_points)
  
  # 创建密度函数（线性插值）
  density_func <- approxfun(kde_result$x, kde_result$y, rule = 2)
  
  # 创建CDF函数（数值积分）
  cdf_func <- function(t) {
    t <- pmin(pmax(t, 0), 1)
    # 使用梯形法则进行数值积分
    x_grid <- seq(0, t, length.out = 200)
    y_grid <- sapply(x_grid, density_func)
    # 梯形法则
    h_cdf <- x_grid[2] - x_grid[1]
    0.5 * h_cdf * (y_grid[1] + 2 * sum(y_grid[-c(1, length(y_grid))]) + y_grid[length(y_grid)])
  }
  
  # 创建分位数函数（CDF的逆函数）
  # 创建查找表以提高效率
  t_dense <- seq(0, 1, length.out = 1000)
  cdf_dense <- sapply(t_dense, cdf_func)
  
  quantile_func <- function(q) {
    q <- pmin(pmax(q, 0.001), 0.999)
    # 对每个q，通过线性插值找到对应的t
    approx(cdf_dense, t_dense, xout = q, rule = 2)$y
  }
  
  return(list(
    density_func = density_func,
    cdf_func = cdf_func,
    quantile_func = quantile_func,
    bandwidth = bw
  ))
}

# 测试核密度估计函数
test_m <- 100
test_observations <- rbeta(test_m, alphas[1], betas[1])
test_est <- estimate_density_kde(test_observations)

# 可视化真实密度与估计密度
t_plot <- seq(0.05, 0.95, length.out = 200)
true_dens_vals <- sapply(t_plot, true_densities[[1]])
est_dens_vals <- sapply(t_plot, test_est$density_func)

comparison_data <- data.frame(
  t = rep(t_plot, 2),
  density = c(true_dens_vals, est_dens_vals),
  type = rep(c("True Density", "Estimated Density"), each = length(t_plot))
)

plot_density_comparison <- ggplot(comparison_data, aes(x = t, y = density, color = type, linetype = type)) +
  geom_line(size = 1) +
  labs(title = paste("True vs Estimated Density (m =", test_m, ")"),
       x = "t", y = "Density f(t)") +
  theme_minimal() +
  theme(legend.position = "bottom", legend.title = element_blank())

print(plot_density_comparison)
```


# 第七步：比较所有m值下的估计密度与真实密度

```{r}
# 8. 比较所有m值下的估计密度与真实密度

# 选择一个个体进行演示
demo_individual <- 25  # 选择中间范围的个体
demo_alpha <- alphas[demo_individual]
demo_beta <- betas[demo_individual]

# 创建展示所有m值下密度估计的综合图表
t_demo <- seq(0.05, 0.95, length.out = 300)
true_density_demo <- dbeta(t_demo, demo_alpha, demo_beta)

# 为每个m值生成估计密度
set.seed(777)  # 为演示设置随机种子

# 创建数据框用于绘图
density_comparison_all <- data.frame()

# 添加真实密度
density_comparison_all <- rbind(density_comparison_all,
                                data.frame(t = t_demo,
                                           density = true_density_demo,
                                           type = "True Density",
                                           m = NA))

# 为每个m值添加估计密度
for(m in m_values) {
  # 生成观测值
  demo_obs <- rbeta(m, demo_alpha, demo_beta)
  
  # 估计密度
  demo_kde <- estimate_density_kde(demo_obs)
  
  # 计算估计密度值
  est_density_vals <- sapply(t_demo, demo_kde$density_func)
  
  # 添加到数据框
  density_comparison_all <- rbind(density_comparison_all,
                                  data.frame(t = t_demo,
                                             density = est_density_vals,
                                             type = "Estimated",
                                             m = m))
}

# 为图表创建颜色调色板
color_palette <- c("True Density" = "black",
                   "50" = "#FF6B6B",     # 红色
                   "100" = "#FFA726",    # 橙色
                   "500" = "#66BB6A",    # 绿色
                   "1000" = "#42A5F5",   # 蓝色
                   "5000" = "#7E57C2",   # 紫色
                   "10000" = "#5D4037")  # 棕色

# 创建综合比较图表
plot_comprehensive_density <- ggplot(density_comparison_all, 
                                     aes(x = t, y = density, 
                                         color = ifelse(is.na(m), "True Density", as.character(m)),
                                         linetype = type,
                                         size = type)) +
  geom_line() +
  scale_color_manual(
    name = "Sample Size",
    values = color_palette,
    breaks = c("True Density", "50", "100", "500", "1000", "5000", "10000"),
    labels = c("True Density", "m = 50", "m = 100", "m = 500", 
               "m = 1000", "m = 5000", "m = 10000")
  ) +
  scale_linetype_manual(
    name = "Density Type",
    values = c("True Density" = "solid", "Estimated" = "dashed"),
    labels = c("Estimated", "True Density")
  ) +
  scale_size_manual(
    name = "Density Type",
    values = c("True Density" = 1.5, "Estimated" = 1),
    labels = c("Estimated", "True Density")
  ) +
  labs(title = "Comparison of True Density and Estimated Densities",
       subtitle = paste("Individual", demo_individual, 
                       "(α =", round(demo_alpha, 2), 
                       ", β =", round(demo_beta, 2), ")"),
       x = "t", 
       y = "Density f(t)") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom",
        legend.box = "vertical",
        legend.spacing.y = unit(0.1, "cm"),
        plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12)) +
  guides(color = guide_legend(nrow = 2, byrow = TRUE),
         linetype = guide_legend(nrow = 1, byrow = TRUE),
         size = guide_legend(nrow = 1, byrow = TRUE))

print(plot_comprehensive_density)
```

# 第八步：定量分析密度估计误差随m的变化

```{r}
# 9. 定量分析：密度估计误差随m增加而减小

# 执行多次模拟以获得稳定的误差估计
n_simulations <- 20  # 每个m值的模拟次数

# 初始化误差结果数据框
density_error_results <- data.frame()

# 对每个m值运行模拟
for(m in m_values) {
  cat("正在为 m =", m, "运行模拟...\n")
  
  mse_values <- numeric(n_simulations)
  
  for(sim in 1:n_simulations) {
    # 从真实Beta分布生成观测值
    demo_obs <- rbeta(m, demo_alpha, demo_beta)
    
    # 使用核密度估计估计密度
    demo_kde <- estimate_density_kde(demo_obs)
    
    # 在网格上计算密度值
    t_eval <- seq(0.1, 0.9, length.out = 100)  # 避免边界问题
    true_vals <- dbeta(t_eval, demo_alpha, demo_beta)
    est_vals <- sapply(t_eval, demo_kde$density_func)
    
    # 计算均方误差
    mse_values[sim] <- mean((true_vals - est_vals)^2)
  }
  
  # 计算汇总统计
  mean_mse <- mean(mse_values)
  sd_mse <- sd(mse_values)
  se_mse <- sd_mse / sqrt(n_simulations)
  
  # 添加到结果数据框
  density_error_results <- rbind(density_error_results,
                                 data.frame(m = m,
                                            mean_mse = mean_mse,
                                            sd_mse = sd_mse,
                                            se_mse = se_mse,
                                            lower_ci = mean_mse - 1.96 * se_mse,
                                            upper_ci = mean_mse + 1.96 * se_mse))
}

# 显示误差结果
cat("\n密度估计误差结果:\n")
print(density_error_results)

# 绘制密度估计误差随样本量变化的图表
plot_density_error <- ggplot(density_error_results, aes(x = m, y = mean_mse)) +
  geom_line(size = 1, color = "darkred") +
  geom_point(size = 3, color = "darkred") +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), 
                width = 0.1, color = "darkred", alpha = 0.7) +
  scale_x_log10(
    breaks = m_values,
    labels = c("50", "100", "500", "1000", "5000", "10000")
  ) +
  scale_y_log10() +
  labs(title = "Density Estimation Error vs Sample Size",
       subtitle = "Kernel density estimation error decreases as sample size increases",
       x = "Sample Size per Individual (m)",
       y = "Mean Squared Error (MSE)") +
  theme_minimal(base_size = 14) +
  theme(panel.grid.major = element_line(color = "grey85"),
        panel.grid.minor = element_line(color = "grey92"),
        plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12))

print(plot_density_error)


# 拟合误差衰减的幂律
if(nrow(density_error_results) > 1) {
  density_error_results$log_m <- log(density_error_results$m)
  density_error_results$log_mse <- log(density_error_results$mean_mse)
  
  error_model <- lm(log_mse ~ log_m, data = density_error_results)
  
  cat("\n=== 密度估计收敛性分析 ===\n")
  cat(sprintf("收敛速率: MSE ~ O(m^{%.3f})\n", coef(error_model)[2]))
  cat(sprintf("R² = %.4f\n", summary(error_model)$r.squared))
  
  # 负指数表示误差随m增加而减小
  if(coef(error_model)[2] < 0) {
    cat("结论：密度估计误差随样本量增加而减小。\n")
  }
}
```

# 第九步：定义函数型回归函数

```{r}
# 10. 定义函数型回归函数

# 这个函数使用变换后的密度函数作为预测变量执行函数型线性回归
perform_functional_regression <- function(transformed_densities_list, Y_values, q_grid) {
  # transformed_densities_list: 变换后的密度函数列表
  # Y_values: 响应值向量
  # q_grid: 分位数点网格
  
  n_individuals <- length(Y_values)
  n_points <- length(q_grid)
  
  # 创建函数型协变量矩阵
  # 每行是一个个体，每列是一个分位数点
  X_matrix <- matrix(0, nrow = n_individuals, ncol = n_points)
  
  for(i in 1:n_individuals) {
    X_matrix[i, ] <- sapply(q_grid, transformed_densities_list[[i]])
  }
  
  # 使用基展开方法进行函数型回归
  n_basis <- 15  # 基函数的数量
  basis <- create.bspline.basis(rangeval = c(0, 1), nbasis = n_basis)
  basis_matrix <- eval.basis(q_grid, basis)
  
  # 将函数型数据投影到基函数上
  beta_coefs <- matrix(0, nrow = n_individuals, ncol = n_basis)
  for(i in 1:n_individuals) {
    # 最小二乘投影，添加小的岭惩罚以增强稳定性
    beta_coefs[i, ] <- solve(t(basis_matrix) %*% basis_matrix + 
                             0.01 * diag(n_basis),  
                            t(basis_matrix) %*% X_matrix[i, ])
  }
  
  # 执行多元回归：Y ~ beta_coefs
  lm_data <- data.frame(Y = Y_values)
  for(j in 1:n_basis) {
    lm_data[[paste0("B", j)]] <- beta_coefs[, j]
  }
  
  # 拟合线性模型
  formula_str <- paste("Y ~", paste(paste0("B", 1:n_basis), collapse = " + "))
  lm_model <- lm(as.formula(formula_str), data = lm_data)
  
  # 提取系数
  gamma <- coef(lm_model)[-1]  # 排除截距项
  
  # 重建估计的β(q)函数
  beta_est <- function(q) {
    q <- pmin(pmax(q, 0), 1)
    basis_vals <- eval.basis(q, basis)
    as.numeric(basis_vals %*% gamma)
  }
  
  return(beta_est)
}
```

# 第十步：主模拟 - 对不同m值进行完整模拟 ？？？

```{r}
# 11. 主模拟：对不同m值进行完整模拟

# 存储结果
beta_estimates <- list()
regression_errors <- data.frame()

# 定义用于评估的分位数网格
q_eval <- seq(0.05, 0.95, length.out = 100)

# 对每个m值运行模拟
for(m_idx in 1:length(m_values)) {
  m <- m_values[m_idx]
  cat("\n运行主模拟: m =", m, "\n")
  
  # 步骤1: 从每个真实密度中生成m个观测值
  observations_list <- list()
  for(i in 1:n) {
    observations_list[[i]] <- rbeta(m, alphas[i], betas[i])
  }
  
  # 步骤2: 使用核密度估计估计密度函数
  estimated_densities <- list()
  estimated_cdfs <- list()
  estimated_quantiles <- list()
  
  for(i in 1:n) {
    kde_result <- estimate_density_kde(observations_list[[i]])
    estimated_densities[[i]] <- kde_result$density_func
    estimated_cdfs[[i]] <- kde_result$cdf_func
    estimated_quantiles[[i]] <- kde_result$quantile_func
  }
  
  # 步骤3: 对估计的密度应用对数分位数密度变换
  transformed_densities_est <- list()
  for(i in 1:n) {
    transformed_densities_est[[i]] <- 
      log_density_quantile_transform(estimated_densities[[i]], 
                                     estimated_cdfs[[i]], 
                                     estimated_quantiles[[i]])
  }
  
  # 步骤4: 使用估计的变换密度执行函数型回归
  beta_est <- perform_functional_regression(transformed_densities_est, Y_true, q_grid_integral)
  
  # 存储估计的beta函数
  beta_estimates[[as.character(m)]] <- beta_est
  
  # 步骤5: 计算估计误差
  beta_true_vals <- sapply(q_eval, true_beta)
  beta_est_vals <- sapply(q_eval, beta_est)
  
  # 计算均方误差
  mse_beta <- mean((beta_true_vals - beta_est_vals)^2)
  
  # 存储误差结果
  regression_errors <- rbind(regression_errors,
                             data.frame(m = m, mse = mse_beta))
  
  cat("  β(q)估计的MSE =", round(mse_beta, 6), "\n")
}

# 显示回归误差结果
cat("\n=== 回归误差结果 ===\n")
print(regression_errors)
```

# 第十一步：可视化结果 - 比较不同m值下的估计系数函数

```{r}
# 12. 可视化：比较不同m值下的估计系数函数

# 创建比较数据
beta_comparison_data <- data.frame()

# 添加真实β函数
beta_true_vals <- sapply(q_eval, true_beta)
beta_comparison_data <- rbind(beta_comparison_data,
                              data.frame(q = q_eval,
                                         beta = beta_true_vals,
                                         type = "True β(q)",
                                         m = NA))

# 为每个m值添加估计的β函数
for(m in m_values) {
  beta_est_func <- beta_estimates[[as.character(m)]]
  if(!is.null(beta_est_func)) {
    beta_est_vals <- sapply(q_eval, beta_est_func)
    beta_comparison_data <- rbind(beta_comparison_data,
                                  data.frame(q = q_eval,
                                             beta = beta_est_vals,
                                             type = "Estimated",
                                             m = m))
  }
}

# 为beta比较创建颜色调色板
beta_color_palette <- c("True β(q)" = "black",
                        "50" = "#FF6B6B",     # 红色
                        "100" = "#FFA726",    # 橙色
                        "500" = "#66BB6A",    # 绿色
                        "1000" = "#42A5F5",   # 蓝色
                        "5000" = "#7E57C2",   # 紫色
                        "10000" = "#5D4037")  # 棕色

# 在同一张图上绘制所有beta函数
plot_beta_comparison <- ggplot(beta_comparison_data, 
                               aes(x = q, y = beta, 
                                   color = ifelse(is.na(m), "True β(q)", as.character(m)),
                                   linetype = type,
                                   size = type)) +
  geom_line() +
  scale_color_manual(
    name = "Sample Size",
    values = beta_color_palette,
    breaks = c("True β(q)", "50", "100", "500", "1000", "5000", "10000"),
    labels = c("True β(q)", "m = 50", "m = 100", "m = 500", 
               "m = 1000", "m = 5000", "m = 10000")
  ) +
  scale_linetype_manual(
    name = "Function Type",
    values = c("True β(q)" = "solid", "Estimated" = "dashed"),
    labels = c("Estimated", "True β(q)")
  ) +
  scale_size_manual(
    name = "Function Type",
    values = c("True β(q)" = 1.5, "Estimated" = 1),
    labels = c("Estimated", "True β(q)")
  ) +
  labs(title = "Comparison of True and Estimated Coefficient Functions",
       subtitle = "Estimated β(q) converges to true β(q) as sample size increases",
       x = "Quantile q",
       y = "β(q)") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom",
        legend.box = "vertical",
        legend.spacing.y = unit(0.1, "cm"),
        plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12)) +
  guides(color = guide_legend(nrow = 2, byrow = TRUE),
         linetype = guide_legend(nrow = 1, byrow = TRUE),
         size = guide_legend(nrow = 1, byrow = TRUE))

print(plot_beta_comparison)

```

# 第十二步：可视化回归误差随m增加而减小
```{r}
# 13. 可视化：回归误差随m增加而减小

# 绘制回归误差随样本量变化的图表
plot_regression_error <- ggplot(regression_errors, aes(x = m, y = mse)) +
  geom_line(size = 1.5, color = "darkred") +
  geom_point(size = 4, color = "darkred") +
  scale_x_log10(
    breaks = m_values,
    labels = c("50", "100", "500", "1000", "5000", "10000")
  ) +
  scale_y_log10() +
  labs(title = "Coefficient Function Estimation Error vs Sample Size",
       subtitle = "Estimation error decreases as sample size per individual increases",
       x = "Sample Size per Individual (m)",
       y = "Mean Squared Error (MSE)") +
  theme_minimal(base_size = 14) +
  theme(panel.grid.major = element_line(color = "grey85"),
        panel.grid.minor = element_line(color = "grey92"),
        plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12))

print(plot_regression_error)


# 14. 研究发现总结
cat("\n=== 模拟研究总结 ===\n")
cat("研究问题：随着每个个体的观测数据增加，密度估计的改善如何提升权重函数估计的精度\n\n")
cat("研究设计：\n")
cat("1. 生成了真实的β(q)函数（两个高斯峰的叠加）\n")
cat("2. 生成了100个真实的密度函数f_i(t)（来自Beta分布族）\n")
cat("3. 应用了对数分位数密度变换并根据真实β(q)生成了响应变量Y\n")
cat("4. 从每个真实密度中抽取了m个观测值\n")
cat("5. 使用核密度估计（KDE）估计了密度函数\n")
cat("6. 对估计的密度应用了变换，并执行了函数型回归\n")
cat("7. 得到了估计的β(q)函数\n\n")
cat("样本量序列：", paste(m_values, collapse = ", "), "\n\n")

cat("主要发现：\n")
cat("1. 随着m增加，密度估计改善（图表：真实密度与估计密度的比较）\n")
cat("2. 随着m增加，估计的β(q)收敛于真实的β(q)（图表：真实与估计系数函数的比较）\n")
cat("3. 密度估计误差和系数函数估计误差都随m增加而减小\n")
cat("   （图表：密度估计误差与样本量，系数函数估计误差与样本量）\n\n")

cat("结论：每个个体的更多观测值 → 更好的密度估计 →\n")
cat("       更好的变换 → 更准确的系数函数估计\n")
```

